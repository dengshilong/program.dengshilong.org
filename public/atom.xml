<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[邓世龙的学习笔记]]></title>
  <subtitle><![CDATA[兼济天下则达,独善其身则穷]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://program.dengshiong.org/"/>
  <updated>2015-12-10T06:07:03.000Z</updated>
  <id>http://program.dengshiong.org/</id>
  
  <author>
    <name><![CDATA[robinjia]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[产生匹配括号的字符串]]></title>
    <link href="http://program.dengshiong.org/2015/12/07/%E4%BA%A7%E7%94%9F%E5%8C%B9%E9%85%8D%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://program.dengshiong.org/2015/12/07/产生匹配括号的字符串/</id>
    <published>2015-12-07T08:42:40.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>请写一个程序，输入一个正整数的值，然后列出所有有n个做括号与n个右括号正确地组成的字符串；当然，正确的左、右括号一定个数一样多。</p>
<p>说明：<br>所谓由括号正确地组成的字符串，指的是如果有一个左括号，那么在它的右边就一定有一个与它相匹配的右括号。(())、()(),就是仅有的两个由两个左括号和两个右括号正确地组成的字符串；((()))、(()())、(())()、()(())、()()()是仅有的5个由3个左括号和3个右括号正确地组成的字符串。</p>
<p>如何产生这样的字符串呢？下面就是一个有用的想法：如果在产生的过程中已经产生了若干左、右括号，为了要把产生的行为完成，还欠R个左括号、L个右括号，那么有没有办法找出产生下一个括号时L与R的关系呢？记住，递归是一个不容忽视的利器。<br>​<br>解法：<br>假设还有left个左括号和right个右括号等待匹配，根据left与right的大小可以分三种情况<br>1.当 left == right 时，此时只能继续放左括号<br>2.当 left &lt; right时，可以有两个选择， 继续放一个左括号或者继续放一个有括号。<br>放左括号时需要判断left是否大于0，只有left大于0时,才能继续放左括号。<br>放右括号时则不需要判断。<br>3.当left &gt; right时，此时没有意义。</p>
<p>写成Java程序如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerateParenthesis</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		generateParenthesis(n, n , n, <span class="string">""</span>, result);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n, </span><br><span class="line">			String s, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s.length() == n * <span class="number">2</span>) &#123;</span><br><span class="line">			result.add(s);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">				generateParenthesis(left - <span class="number">1</span>, right, n , s + <span class="string">"("</span>, result);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">				<span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					generateParenthesis(left - <span class="number">1</span>, right, n , s + <span class="string">"("</span>, result);</span><br><span class="line">				&#125;</span><br><span class="line">				generateParenthesis(left, right - <span class="number">1</span>, n, s + <span class="string">")"</span>, result);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; result = generateParenthesis(<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span> (String s: result) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还可以对程序进行优化，因为递归过程会产生许多字符串，可以用数组来解决这个问题。修改程序如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerateParenthesis</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">char</span>[] str = <span class="keyword">new</span> <span class="keyword">char</span>[n * <span class="number">2</span>];</span><br><span class="line">		generateParenthesis(n, n , str, <span class="number">0</span>, result);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">char</span>[] str, </span><br><span class="line">			<span class="keyword">int</span> length, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (length == str.length) &#123;</span><br><span class="line">			result.add(String.valueOf(str));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">				str[length] = <span class="string">'('</span>;</span><br><span class="line">				generateParenthesis(left - <span class="number">1</span>, right, str, length + <span class="number">1</span>, result);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">				<span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					str[length] = <span class="string">'('</span>;</span><br><span class="line">					generateParenthesis(left - <span class="number">1</span>, right, str, length + <span class="number">1</span>, result);</span><br><span class="line">				&#125;</span><br><span class="line">				str[length] = <span class="string">')'</span>;</span><br><span class="line">				generateParenthesis(left, right - <span class="number">1</span>, str, length + <span class="number">1</span>, result);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; result = generateParenthesis(<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span> (String s: result) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>请写一个程序，输入一个正整数的值，然后列出所有有n个做括号与n个右括号正确地组成的字符串；当然，正确的左、右括号一定个数一样多。</p>
<p>说明：<br>所谓由括号正确地组成的字符串，指的是如果有一个左括号，那么在它的右边就一定有一个与它相匹配的右括号。(())、()(]]>
    </summary>
    
      <category term="C名题百则" scheme="http://program.dengshiong.org/tags/C%E5%90%8D%E9%A2%98%E7%99%BE%E5%88%99/"/>
    
      <category term="算法" scheme="http://program.dengshiong.org/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[产生所有排列--字典顺序(非递归解)]]></title>
    <link href="http://program.dengshiong.org/2015/11/02/%E4%BA%A7%E7%94%9F%E6%89%80%E6%9C%89%E6%8E%92%E5%88%97--%E5%AD%97%E5%85%B8%E9%A1%BA%E5%BA%8F(%E9%9D%9E%E9%80%92%E5%BD%92%E8%A7%A3)/"/>
    <id>http://program.dengshiong.org/2015/11/02/产生所有排列--字典顺序(非递归解)/</id>
    <published>2015-11-02T13:42:50.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>编写一个程序，用字典顺序列出n个元素的所有排列(Permutation).​<br>说明:<br>下面是一个n = 4，用字典顺序列出来的所有排列，一共为4! = 24个。<br>1234 2134 3124 4123<br>1243 2143 3142 4132<br>1324 2314 3214 4213<br>1342 2341 3241 4231<br>1423 2413 3412 4312<br>1432 2431 3421 4321​</p>
<p>在<a href="http://program.dengshilong.org/2015/10/31/%E4%BA%A7%E7%94%9F%E6%89%80%E6%9C%89%E6%8E%92%E5%88%97-%E5%AD%97%E5%85%B8%E9%A1%BA%E5%BA%8F/" target="_blank" rel="external">产生所有排列–字典顺序</a>中，用了递归的方法求解字典排列，这里使用非递归的方法。据Hall和Knuth的考证，200多年前(1812年)Fischer和Kruse在一本书中就提到了这个方法.</p>
<p>step 1: 从右往左找，找到第一个i使得nums[i] &lt; nums[i + 1]<br>step 2: 从右往左找，找到第一个j使得nums[i] &lt; nums[j]<br>step 3: 交换nums[i]与nums[j]<br>step 4: 将nums[i + 1],…nums[n]反转<br>在step 1时，如果找不到满足条件的i, 则结束程序。</p>
<p>例如153642,<br>从右往左找，找到第一个 i = 2 使得nums[i] &lt; nums[i + 1] 即3 &lt; 6<br>从右往左找，找到第一个 j = 3 使得nums[i] &lt; nums[j] 即 3 &lt; 4<br>交换nums[i]和nums[j], 得到154632<br>将nums[i + ],..nums[n]反转，即将632反转，得到154236<br>所以154236就是153642的下一个排列。</p>
<p>如此从要求12…n的字典排列，可以从12,…n开始，一直用求下一个排列的方法列出所有排列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> t: nums) &#123;</span><br><span class="line">				temp.add(t);		</span><br><span class="line">			&#125;</span><br><span class="line">			result.add(temp);</span><br><span class="line">			<span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt; nums[i + <span class="number">1</span>]) </span><br><span class="line">				i--;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (j &gt; i &amp;&amp; nums[i] &gt; nums[j])</span><br><span class="line">				j--;</span><br><span class="line">			swap(nums, i, j);</span><br><span class="line">			reverse(nums, i + <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = nums[i];</span><br><span class="line">		nums[i] = nums[j];</span><br><span class="line">		nums[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">			swap(nums, begin, end);</span><br><span class="line">			begin++;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; result = permute(nums);</span><br><span class="line">		<span class="keyword">for</span> (List&lt;Integer&gt; list: result) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Integer i: list) &#123;</span><br><span class="line">				System.out.print(i);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			System.out.print(nums[i] + <span class="string">" "</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>编写一个程序，用字典顺序列出n个元素的所有排列(Permutation).​<br>说明:<br>下面是一个n = 4，用字典顺序列出来的所有排列，一共为4! = 24个。<br>1234 2134 3124 4123<br>1243 2143 3142 4132<br>1]]>
    </summary>
    
      <category term="C名题百则" scheme="http://program.dengshiong.org/tags/C%E5%90%8D%E9%A2%98%E7%99%BE%E5%88%99/"/>
    
      <category term="算法" scheme="http://program.dengshiong.org/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[产生所有排列--字典顺序]]></title>
    <link href="http://program.dengshiong.org/2015/10/31/%E4%BA%A7%E7%94%9F%E6%89%80%E6%9C%89%E6%8E%92%E5%88%97--%E5%AD%97%E5%85%B8%E9%A1%BA%E5%BA%8F/"/>
    <id>http://program.dengshiong.org/2015/10/31/产生所有排列--字典顺序/</id>
    <published>2015-10-31T02:01:09.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>编写一个程序，用字典顺序列出n个元素的所有排列(Permutation).</p>
<p>说明:<br>下面是一个n = 4，用字典顺序列出来的所有排列，一共为4! = 24个。<br>1234    2134    3124    4123<br>1243    2143    3142    4132<br>1324    2314    3214    4213<br>1342    2341    3241    4231<br>1423    2413    3412    4312<br>1432    2431    3421    4321</p>
<p>这里是一个递归的做法。看上面4! = 24个排列的第一列，它们的第一个元素都是1，第一列的最后一个是以1开头，用字典顺序排出来的最后，自然是1432.事实上，如果是n个元素的排列，以1开头的最后一个应该是1n(n-1)…432。下一列是2开头，把n(n-1)…432中最小的一个与第一个互换，也就是把倒数第一个与第一个互换，得到2n(n-1)..431，但这不是1n(n-1)…432的下一个，但是如果把后面的n - 1个元素反过来，就会得到2134…(n-1)n，是正确的顺序，于是进入第二列。</p>
<p>第二列的最后一个应该是2n(n-1)…431,把 n(n-1)…431中最小的与第一个互换，但因为1已经出现过了，所以把倒数第二个元素(自然是3)与第一个互换，得到3n(n-1)…421，再把后面的n - 1个元素反过来，得到3124…(n-1)n，就得到第三列的第一个。</p>
<p>第三列的最后一个是3n(n-1)…421, 把n(n-1)…421中最小的与第一个互换，但因为1，2已经出现过了，所以把倒数第3个元素(自然是4)与第一个互换，得到4n(n-1)…321，再将后面n - 1个反过来排，得到4123…(n - 1)n，正好是第4列的第一个元素。</p>
<p>于是我们可以得到一个递归的做法，从1234…n起，用一个递归的程序<br>1. i = n<br>2. 对后面n - 1个进行排列(递归的)<br>3. 把第i位与第1位互换<br>4. i减去1​<br>5. 把后面的n - 1位反过来排<br>6. 回到第2步<br>当i到第一位时程序结束。</p>
<p>需要注意的一点是，排序结束后，数组元素的位置是逆置的，要保证不改变数组元素，我们需要将数组进行一个逆置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutions</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		permute(nums, <span class="number">0</span>, result);</span><br><span class="line">		reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>); <span class="comment">//after permutation, we need to reverse array</span></span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = nums[i];</span><br><span class="line">		nums[i] = nums[j];</span><br><span class="line">		nums[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">			swap(nums, begin, end);</span><br><span class="line">			begin++;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (start == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">			List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">				temp.add(nums[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			result.add(temp);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> i = nums.length;</span><br><span class="line">		<span class="keyword">while</span> (i &gt; start) &#123;</span><br><span class="line">			permute(nums, start + <span class="number">1</span>, result);</span><br><span class="line">			swap(nums, start, i - <span class="number">1</span>);</span><br><span class="line">			i--;</span><br><span class="line">			<span class="keyword">if</span> (i &lt;= start)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			reverse(nums, start + <span class="number">1</span>, nums.length - <span class="number">1</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; result = permute(nums);</span><br><span class="line">		<span class="keyword">for</span> (List&lt;Integer&gt; list: result) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Integer i: list) &#123;</span><br><span class="line">				System.out.print(i);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			System.out.print(nums[i] + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>编写一个程序，用字典顺序列出n个元素的所有排列(Permutation).</p>
<p>说明:<br>下面是一个n = 4，用字典顺序列出来的所有排列，一共为4! = 24个。<br>1234    2134    3124    4123<br>1243    2143]]>
    </summary>
    
      <category term="C名题百则" scheme="http://program.dengshiong.org/tags/C%E5%90%8D%E9%A2%98%E7%99%BE%E5%88%99/"/>
    
      <category term="算法" scheme="http://program.dengshiong.org/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[N后问题递归解]]></title>
    <link href="http://program.dengshiong.org/2015/10/30/N%E5%90%8E%E9%97%AE%E9%A2%98%E9%80%92%E5%BD%92%E8%A7%A3/"/>
    <id>http://program.dengshiong.org/2015/10/30/N后问题递归解/</id>
    <published>2015-10-30T07:49:43.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>8后问题(Eight Queen Problem)是指在一个8 <em> 8的西洋棋盘上要如何放置8个皇后棋且不会互相吃到对方；皇后棋可以吃掉任何它所在的那一列、那一行，以及那两个对角线(米字形)上的任何棋子。请写一个程序，读入一个值n表示棋盘的大小，然后求出n </em> n格棋盘上放n个皇后棋且不会相互吃掉对方的所有解答。</p>
<p>说明。这是广义的N后问题，因为所要求的是“所有”解答，而不单是其中的一组，对大多数会运用递归的人来说，这个题目反而容易做些。这一类型题目的揭发通常要用到回溯(Backtrack)的技巧–不管用递归还是不用递归都是如此，虽然会浪费时间，但多半会找到答案。</p>
<p>依据题意，写了一个递归的方法，判断是否能放置皇后时有点麻烦，应该有更简便的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NQueens</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] board = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">return</span> totalNQueens(<span class="number">0</span>, n, board);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//check if queen can put on board[row][col]</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canPutCheck</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> n, <span class="keyword">boolean</span>[][] board)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (board[row][i]) <span class="comment">//row</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (board[i][col]) <span class="comment">//col</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//diagonal</span></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (row + i &lt; n &amp;&amp; col + i &lt; n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (board[row + i][col +i])</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (row - i &gt;= <span class="number">0</span> &amp;&amp; col - i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (board[row - i][col - i])</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//back diagonal</span></span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (row + i &lt; n &amp;&amp; col - i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (board[row + i][col - i])</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (row - i &gt;= <span class="number">0</span> &amp;&amp; col + i &lt; n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (board[row - i][col + i])</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n, <span class="keyword">boolean</span>[][] board)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (row == n) &#123; </span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (canPutCheck(row, j, n, board)) &#123;</span><br><span class="line">				board[row][j] = <span class="keyword">true</span>;</span><br><span class="line">				count += totalNQueens(row + <span class="number">1</span>, n, board);</span><br><span class="line">				board[row][j] = <span class="keyword">false</span>; <span class="comment">//backtrack</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">			System.out.println(i + <span class="string">" "</span> + totalNQueens(i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>8后问题(Eight Queen Problem)是指在一个8 <em> 8的西洋棋盘上要如何放置8个皇后棋且不会互相吃到对方；皇后棋可以吃掉任何它所在的那一列、那一行，以及那两个对角线(米字形)上的任何棋子。请写一个程序，读入一个值n表示棋盘的大小，然后求出n </em>]]>
    </summary>
    
      <category term="C名题百则" scheme="http://program.dengshiong.org/tags/C%E5%90%8D%E9%A2%98%E7%99%BE%E5%88%99/"/>
    
      <category term="算法" scheme="http://program.dengshiong.org/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[产生Gray码]]></title>
    <link href="http://program.dengshiong.org/2015/10/29/%E4%BA%A7%E7%94%9FGray%E7%A0%81/"/>
    <id>http://program.dengshiong.org/2015/10/29/产生Gray码/</id>
    <published>2015-10-29T08:40:43.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>编写一个程序，用Gray码(Gray Code)的顺序列出一个集合的所有子集。</p>
<p>什么是Gray码? nbit的Gray码是一连串共有2的n次方个元素的数列，每一个元素都有nbit,而且任何相邻的两个元素之间都只有1bit的值不同。例如，<br>两个bit的Gray码:<br>00 01 11 10 是一组Gray码<br>3个bit的Gray码:<br>000 001 011 010 110 111 101 100 是一组Gray码<br>但是Gray码并不是惟一的，把他循环排列或是用反过来的顺序写，也会得到一组Gray码；比如说，如果把3bitGray码的最后3个元素放在前面去，就会得到:<br>111 101 100 000 001 011 010 110 也是一组Gray码</p>
<p>产生Gray码的方法很多，这里这介绍其中一种。<br>将2bit Gray码列出<br>00<br>01<br>11<br>10<br>将3bit Gray码列出<br>000<br>001<br>011<br>010<br>110<br>111<br>101<br>100<br>观察3bit Gray码可以发现，它可以由2bit Gray码来得到。<br>3bit Gray码的前四个由2bit Gray码从第一个到最后一个在最前面的加上0得到<br>3bit Gray码的后四个 可以将2bit Gray从最后一个到第一个在最前面加上1得到<br>写成代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrayCode</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	     List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	     <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">	    	 result.add(<span class="number">0</span>);</span><br><span class="line">	     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    	 List&lt;Integer&gt; temp = grayCode(n-<span class="number">1</span>);</span><br><span class="line">	    	 <span class="keyword">for</span> (Integer i: temp) &#123;</span><br><span class="line">	    		 result.add(i);</span><br><span class="line">	    	 &#125;</span><br><span class="line">	    	 <span class="keyword">for</span> (<span class="keyword">int</span> i = temp.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">	    		 result.add(temp.get(i) + (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)));</span><br><span class="line">	    	 &#125;</span><br><span class="line">	     &#125;</span><br><span class="line">	     <span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;Integer&gt; result = grayCode(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (Integer i: result) &#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>编写一个程序，用Gray码(Gray Code)的顺序列出一个集合的所有子集。</p>
<p>什么是Gray码? nbit的Gray码是一连串共有2的n次方个元素的数列，每一个元素都有nbit,而且任何相邻的两个元素之间都只有1bit的值不同。例如，<br>两个bit的Gr]]>
    </summary>
    
      <category term="C名题百则" scheme="http://program.dengshiong.org/tags/C%E5%90%8D%E9%A2%98%E7%99%BE%E5%88%99/"/>
    
      <category term="算法" scheme="http://program.dengshiong.org/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[查找矩阵]]></title>
    <link href="http://program.dengshiong.org/2015/10/29/%E6%9F%A5%E6%89%BE%E7%9F%A9%E9%98%B5/"/>
    <id>http://program.dengshiong.org/2015/10/29/查找矩阵/</id>
    <published>2015-10-29T03:53:15.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>已知一个m行n列的矩阵M,它的元素满足一个很特殊的性质，即任一元素M[i][j]都小于它右边与下方的元素(如果存在的话),换言之，M[i][j] &lt; M[i][j + 1]且M[i][j] &lt; M[i + 1][j]。如int[ ][ ] nums = { {1, 4, 7, 11, 15},{2, 5, 8, 12, 19},{3, 6, 9, 16, 22},{10, 13, 14, 17, 24},{18, 21, 23, 26, 30}};</p>
<p>现在有一个值K，编写一个程序，检查矩阵M中是否有K。</p>
<p>对于矩阵M，可以将它划分成两部分区域，一部分是小于等于K的区域，一部分是大于K的区域。沿着两部分区域的边界线查找K即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchaMatrix</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = matrix.length;</span><br><span class="line">		<span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">        		j--;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) &#123;</span><br><span class="line">        		i++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        	&#125;   	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[][] nums = &#123; &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;,&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>&#125;,&#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>&#125;,&#123;<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>&#125;,&#123;<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line">		System.out.println(searchMatrix(nums, <span class="number">17</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>已知一个m行n列的矩阵M,它的元素满足一个很特殊的性质，即任一元素M[i][j]都小于它右边与下方的元素(如果存在的话),换言之，M[i][j] &lt; M[i][j + 1]且M[i][j] &lt; M[i + 1][j]。如int[ ][ ] nums = { {1]]>
    </summary>
    
      <category term="C名题百则" scheme="http://program.dengshiong.org/tags/C%E5%90%8D%E9%A2%98%E7%99%BE%E5%88%99/"/>
    
      <category term="算法" scheme="http://program.dengshiong.org/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最大连续元素和]]></title>
    <link href="http://program.dengshiong.org/2015/10/26/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%85%83%E7%B4%A0%E5%92%8C/"/>
    <id>http://program.dengshiong.org/2015/10/26/最大连续元素和/</id>
    <published>2015-10-26T09:08:41.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>已知数组x[ ]储存了一组整数，请写一个程序，找出在数组中连续元素的和中最大的一个。举例而言，如果有数组1，2，-6，3，-2，4，-1，3，2，-4，那么连续的元素和有1 + 2 = 3，1 + 2 + (-6) = -3，2 + (-6) = -4，。。。，但最大的就是3 + (-2) + 4 + (-1) + 3 + 2这一段，值为9。这个题目通常叫做最大连续元素和问题，或者叫做最大连续子数组。</p>
<p>一个自然的办法是使用双重循环，但是性能不好。这个问题要求O(n)解法，需要动点脑筋。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumSubarray</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				sum = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			sum += nums[i];</span><br><span class="line">			result = Math.max(result, sum);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;      </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, -<span class="number">6</span>, <span class="number">3</span>, -<span class="number">2</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">4</span>&#125;;</span><br><span class="line">		System.out.println(maxSubArray(nums));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有一种是分治的方法，效率慢一些<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumSubarray</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> maxSubArray(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">			<span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[left];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> middle = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">			<span class="keyword">int</span> leftMax = maxSubArray(nums, left, middle);</span><br><span class="line">			<span class="keyword">int</span> rightMax = maxSubArray(nums, middle + <span class="number">1</span>, right);</span><br><span class="line">			<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> maxToLeft = Integer.MIN_VALUE;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = middle; i &gt;= left; i--) &#123;</span><br><span class="line">				sum += nums[i];</span><br><span class="line">				maxToLeft = Math.max(maxToLeft, sum);</span><br><span class="line">			&#125;</span><br><span class="line">			sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> maxToRight = Integer.MIN_VALUE;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = middle + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">				sum += nums[i];</span><br><span class="line">				maxToRight = Math.max(maxToRight, sum);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> result = maxToLeft + maxToRight;</span><br><span class="line">			result = Math.max(result, leftMax);</span><br><span class="line">			result = Math.max(result, rightMax);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, -<span class="number">6</span>, <span class="number">3</span>, -<span class="number">2</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">4</span>&#125;;</span><br><span class="line">		System.out.println(maxSubArray(nums));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>已知数组x[ ]储存了一组整数，请写一个程序，找出在数组中连续元素的和中最大的一个。举例而言，如果有数组1，2，-6，3，-2，4，-1，3，2，-4，那么连续的元素和有1 + 2 = 3，1 + 2 + (-6) = -3，2 + (-6) = -4，。。。，但最大的就是]]>
    </summary>
    
      <category term="C名题百则" scheme="http://program.dengshiong.org/tags/C%E5%90%8D%E9%A2%98%E7%99%BE%E5%88%99/"/>
    
      <category term="算法" scheme="http://program.dengshiong.org/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[等值首尾和]]></title>
    <link href="http://program.dengshiong.org/2015/10/22/%E7%AD%89%E5%80%BC%E9%A6%96%E5%B0%BE%E5%92%8C/"/>
    <id>http://program.dengshiong.org/2015/10/22/等值首尾和/</id>
    <published>2015-10-22T08:16:54.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>假设有一个数组x[ ], 它有n个元素，每一个都大于零，称x[0] + x[1] + … + x[i]为前置和(Prefix Sum),而 x[j] + x[j + 1] + … + x[n - 1]为后置和(Suffix Sum)。试编写一个程序，求出x[ ] 中有多少组相同的前置和与后置和。</p>
<p>说明<br>如果x[ ] 的元素是3，6，2，1，4，5，2，则x[ ]的前置和有一下7个，即3，9，11，12，16，21，23；后置和则是2，7，11，12，14，20，23；于是11，12，与23这3对就是值相同的前置和与后置和，因为：<br>11 = 3 + 6 + 2(前置和) = 2 + 5 + 4 (后置和)<br>12 = 3 + 6 + 2 + 1(前置和) = 2 + 5 + 4 + 1 (后置和)<br>因为23是整个数组元素的和，因此前置和与后置和一定相同。</p>
<p>可以用变量prefix来表示前置和，用suffix来表示后置和，用i表示前置和累加元素的位置，i从前往后加，用j表示后置和累加元素的位置, j从后往前加。当prefix &gt; suffix时，累加后置和，也就是j向前走；当prefix &lt; suffix时，累加前置和，也就是i往后走；当prefix == suffix时，同时累加前置和与后置和，也就是i往后走，j往前走</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadTail</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">headTail</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> prefix = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> suffix = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; nums.length &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(prefix + <span class="string">" "</span> + suffix + <span class="string">" "</span> + i + <span class="string">" "</span> + j);</span><br><span class="line">			<span class="keyword">if</span> (prefix == suffix) &#123;		</span><br><span class="line">				prefix += nums[i++];</span><br><span class="line">				suffix += nums[j--];</span><br><span class="line">				result++;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (prefix &gt; suffix) &#123;</span><br><span class="line">				suffix += nums[j--];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;			</span><br><span class="line">				prefix += nums[i++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>&#125;;</span><br><span class="line">		System.out.println(headTail(nums));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>假设有一个数组x[ ], 它有n个元素，每一个都大于零，称x[0] + x[1] + … + x[i]为前置和(Prefix Sum),而 x[j] + x[j + 1] + … + x[n - 1]为后置和(Suffix Sum)。试编写一个程序，求出x[ ] 中有多少组]]>
    </summary>
    
      <category term="C名题百则" scheme="http://program.dengshiong.org/tags/C%E5%90%8D%E9%A2%98%E7%99%BE%E5%88%99/"/>
    
      <category term="算法" scheme="http://program.dengshiong.org/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[两数组最短距离]]></title>
    <link href="http://program.dengshiong.org/2015/10/22/%E4%B8%A4%E6%95%B0%E7%BB%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"/>
    <id>http://program.dengshiong.org/2015/10/22/两数组最短距离/</id>
    <published>2015-10-22T07:35:45.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>已知两个元素从小到大排列的数组x[]与y[],请编写一个程序算出两个数组元素彼此之间差的绝对值最小的一个树，此值称为数组的距离。</p>
<p>说明： 如果x[i]与y[i]是两个元素，那么 |x[i] - y[i]| 就是这两个元素之间的距离，所有这些距离的最小值，称为数组的距离。比如说x[]有1，3，5，7，9， y[]有2，6，8，那么最短距离就是1，因为x[0]与y[0]、 x[1]与y[0]、x[2]与y[1]、x[3]与y[1]、还有x[4]与y[2]的距离都是1。</p>
<p>依然是利用数组已经排好序的特性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinDist</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDist</span><span class="params">(<span class="keyword">int</span>[] x, <span class="keyword">int</span>[] y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; x.length &amp;&amp; j &lt; y.length) &#123;	</span><br><span class="line">			<span class="keyword">if</span> (x[i] &gt;= y[j]) &#123;</span><br><span class="line">				result = Math.min(result, x[i] - y[j]);</span><br><span class="line">				j++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				result = Math.min(result, y[j] - x[i]);</span><br><span class="line">				i++;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] x = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] y = &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">		System.out.println(minDist(x, y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>已知两个元素从小到大排列的数组x[]与y[],请编写一个程序算出两个数组元素彼此之间差的绝对值最小的一个树，此值称为数组的距离。</p>
<p>说明： 如果x[i]与y[i]是两个元素，那么 |x[i] - y[i]| 就是这两个元素之间的距离，所有这些距离的最小值，称为数]]>
    </summary>
    
      <category term="C名题百则" scheme="http://program.dengshiong.org/tags/C%E5%90%8D%E9%A2%98%E7%99%BE%E5%88%99/"/>
    
      <category term="算法" scheme="http://program.dengshiong.org/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[等值数目]]></title>
    <link href="http://program.dengshiong.org/2015/10/22/%E7%AD%89%E5%80%BC%E6%95%B0%E7%9B%AE/"/>
    <id>http://program.dengshiong.org/2015/10/22/等值数目/</id>
    <published>2015-10-22T07:31:31.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>已知两个整数数组f[]与g[]，它们的元素都已经从小到大排列好，而且两个数组中的元素都各不相同。例如，f[]中有1,3,4,7,9,而g[]中有3,5,7,8,10。试编写程序算出这两个数组之间有多少组相同的元素。</p>
<p>就上例而言，f[2]和g[1]为3是一组​；f[3]与g[2]为7是第二组</p>
<p>依然是利用已经排好序的这个特性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EQCount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">eqCount</span><span class="params">(<span class="keyword">int</span>[] f, <span class="keyword">int</span>[] g)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; f.length &amp;&amp; j &lt; g.length) &#123;</span><br><span class="line">			<span class="keyword">if</span> (f[i] == g[j]) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">				result++;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (f[i] &gt; g[j]) &#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] f = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] g = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">		System.out.println(eqCount(f, g));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>已知两个整数数组f[]与g[]，它们的元素都已经从小到大排列好，而且两个数组中的元素都各不相同。例如，f[]中有1,3,4,7,9,而g[]中有3,5,7,8,10。试编写程序算出这两个数组之间有多少组相同的元素。</p>
<p>就上例而言，f[2]和g[1]为3是一组​；]]>
    </summary>
    
      <category term="C名题百则" scheme="http://program.dengshiong.org/tags/C%E5%90%8D%E9%A2%98%E7%99%BE%E5%88%99/"/>
    
      <category term="算法" scheme="http://program.dengshiong.org/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[支配值数目]]></title>
    <link href="http://program.dengshiong.org/2015/10/22/%E6%94%AF%E9%85%8D%E5%80%BC%E6%95%B0%E7%9B%AE/"/>
    <id>http://program.dengshiong.org/2015/10/22/支配值数目/</id>
    <published>2015-10-22T07:14:00.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>已知f[]与g[]两个整数数组，元素已经从小到大排列，请写一个程序，算出f[]中比g[]元素大的对数。换句话说，f[0]比g[]中多少个元素大，f[1]比g[]中多少元素大等，这些值的总和就是要求的答案。</p>
<p>例如，如果f[]中有1，3，5，7，9，而g[]中有2，3，4，7，8，比g[0]大的有f[1]~f[4], 比g[1]大的有f[2]~f[4]，比g[2]大的有f[2]~f[4]，比g[3]大的有f[4]，比g[4]大的有f[4]，因此答案是4 + 3 + 3 + 1 + 1 = 12</p>
<p>利用数组已经排好序的这个特性，可以写出高效的程序.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GTCount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gtCount</span><span class="params">(<span class="keyword">int</span>[] f, <span class="keyword">int</span>[] g)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; f.length &amp;&amp; j &lt; g.length) &#123;</span><br><span class="line">			<span class="keyword">if</span> (f[i] &gt; g[j]) &#123;</span><br><span class="line">				result += f.length - i;</span><br><span class="line">				j++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] f = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] g = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">		System.out.println(gtCount(f, g));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>已知f[]与g[]两个整数数组，元素已经从小到大排列，请写一个程序，算出f[]中比g[]元素大的对数。换句话说，f[0]比g[]中多少个元素大，f[1]比g[]中多少元素大等，这些值的总和就是要求的答案。</p>
<p>例如，如果f[]中有1，3，5，7，9，而g[]中有2]]>
    </summary>
    
      <category term="C名题百则" scheme="http://program.dengshiong.org/tags/C%E5%90%8D%E9%A2%98%E7%99%BE%E5%88%99/"/>
    
      <category term="算法" scheme="http://program.dengshiong.org/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最长平台]]></title>
    <link href="http://program.dengshiong.org/2015/10/22/%E6%9C%80%E9%95%BF%E5%B9%B3%E5%8F%B0/"/>
    <id>http://program.dengshiong.org/2015/10/22/最长平台/</id>
    <published>2015-10-22T06:32:33.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>最近又把冼镜光的《C语言名题精选百则–技巧篇》拿出来看看，确实不错。</p>
<p>已知一个已经从小到大排序的数组，这个数组中的一个平台(plateau) 就是连续的一串相同的元素，并且这一串元素不能再延伸。例如，在1，2，2，3，3，3，4，5，5，6中1，2.2，3.3.3，4，5.5，6都是平台。试编写一个程序，接受一个数组，把这个数组中最长的平台找出来。在上面的例子中，3.3.3就是该数组的最长平台。<br>这个问题曾经困扰过计算机科学家David Gries，他给出的方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pleateau</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pleateau</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] == nums[i - length]) &#123;</span><br><span class="line">				length++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">		System.out.println(pleateau(nums));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己想到的方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pleateau</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pleateau</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i + length &lt; nums.length) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] == nums[i + length]) &#123;</span><br><span class="line">				length++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				i += length;</span><br><span class="line">				<span class="keyword">while</span> (i &lt; nums.length &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp;  nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">					i--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">		System.out.println(pleateau(nums));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>最近又把冼镜光的《C语言名题精选百则–技巧篇》拿出来看看，确实不错。</p>
<p>已知一个已经从小到大排序的数组，这个数组中的一个平台(plateau) 就是连续的一串相同的元素，并且这一串元素不能再延伸。例如，在1，2，2，3，3，3，4，5，5，6中1，2.2，3.3]]>
    </summary>
    
      <category term="C名题百则" scheme="http://program.dengshiong.org/tags/C%E5%90%8D%E9%A2%98%E7%99%BE%E5%88%99/"/>
    
      <category term="算法" scheme="http://program.dengshiong.org/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Solr权限控制solrj认证]]></title>
    <link href="http://program.dengshiong.org/2015/01/22/Solr%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6solrj%E8%AE%A4%E8%AF%81/"/>
    <id>http://program.dengshiong.org/2015/01/22/Solr权限控制solrj认证/</id>
    <published>2015-01-22T11:44:28.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>在上篇中，我们通过在jetty中配置，是update需要进行用户名和密码认证，这篇中我们继续介绍如何在solrj中调用update</p>
<p>*测试添加文档<br>先尝试使用solrj,编写测试程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"http://localhost:8989/solr"</span>; </span><br><span class="line">HttpSolrServer server = <span class="keyword">new</span> HttpSolrServer(url); </span><br><span class="line">SolrInputDocume doc1 = <span class="keyword">new</span> SolrInputDocument(); </span><br><span class="line">server.add(docs);</span><br></pre></td></tr></table></figure></p>
<p>提示401错误,添加用户名和密码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"http://localhost:8989/solr"</span>; </span><br><span class="line">HttpSolrServer server = <span class="keyword">new</span> HttpSolrServer(url); </span><br><span class="line">HttpClientUtil.setBasicAuth((DefaultHttpClient) server.getHttpClient(), <span class="string">"index"</span>, <span class="string">"update"</span>); </span><br><span class="line">SolrInputDocume doc1 = <span class="keyword">new</span> SolrInputDocument(); </span><br><span class="line">server.add(docs);</span><br></pre></td></tr></table></figure></p>
<p>提示 NonRepeatableRequestException, Cannot retry request with a non-repeatable request entity. 想跟踪过去,看看错误出自哪里,没办法调到源代码,于是尝试查询.<br><em>测试查询文档<br>将etc/webdefault.xml中对<url-pattern>/update/</url-pattern></em>的限制改成,<url-pattern>/select/*</url-pattern>,编写查询代码,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"http://localhost:8989/solr"</span>; </span><br><span class="line">HttpSolrServer server = <span class="keyword">new</span> HttpSolrServer(url); </span><br><span class="line">SolrQuery query = <span class="keyword">new</span> SolrQuery(); </span><br><span class="line">String q = <span class="string">"*:*"</span>; </span><br><span class="line">query.setQuery(q);</span><br></pre></td></tr></table></figure></p>
<p>提示401错误,添加用户名和密码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"http://localhost:8989/solr"</span>; </span><br><span class="line">HttpSolrServer server = <span class="keyword">new</span> HttpSolrServer(url); </span><br><span class="line">SolrQuery query = <span class="keyword">new</span> SolrQuery(); </span><br><span class="line">String q = <span class="string">"*:*"</span>; </span><br><span class="line">query.setQuery(q);</span><br></pre></td></tr></table></figure></p>
<p>查询成功, </p>
<p>*问题解决<br>不明白原因,只是猜测post的信息不能反复使用,在setBasicAuth前面有一段说明, “Currently this is not preemtive authentication. So it is<br>not currently possible to do a post request while using this setting.”,意思就是认证过程不是最先进行的,所以现在不能用于post,可是认证<br>过程可以用于get,于是察看get的执行过程,发现它先执行一次,发现要认证,于是再执行一次,而第二次执行时会先执行认证过程. 对于post过程,如果<br>可以执行同样的过程,那就可以达到目的,关键问题是”Cannot retry request with a non-repeatable request entity”,于是查看solr-4470是如何<br>实现的,看到HttpSolrServer里代码如下:<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (contentStream[<span class="number">0</span>] <span class="keyword">instanceof</span> RequestWriter.LazyContentStream) &#123;</span><br><span class="line">   post.setEntity(<span class="keyword">new</span> InputStreamEntity(contentStream[<span class="number">0</span>].getStream(), -<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="annotation">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Header <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> BasicHeader(<span class="string">"Content-Type"</span>, contentStream[<span class="number">0</span>].getContentType());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="annotation">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRepeatable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   post.setEntity(<span class="keyword">new</span> InputStreamEntity(contentStream[<span class="number">0</span>].getStream(), -<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="annotation">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Header <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> BasicHeader(<span class="string">"Content-Type"</span>, contentStream[<span class="number">0</span>].getContentType());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="annotation">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRepeatable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>修改成<br>     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HttpEntity entity = <span class="keyword">new</span> InputStreamEntity(contentStream[<span class="number">0</span>].getStream(), -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Header <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicHeader(<span class="string">"Content-Type"</span>, contentStream[<span class="number">0</span>].getContentType());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRepeatable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">entity = <span class="keyword">new</span> BufferedHttpEntity(entity);</span><br></pre></td></tr></table></figure></p>
<p>在生产环境中，可以添加参数控制是否需要entity = new BufferedHttpEntity(entity);和<br>HttpClientUtil.setBasicAuth((DefaultHttpClient) server.getHttpClient(), “index”, “update”);这两句</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上篇中，我们通过在jetty中配置，是update需要进行用户名和密码认证，这篇中我们继续介绍如何在solrj中调用update</p>
<p>*测试添加文档<br>先尝试使用solrj,编写测试程序<br><figure class="highlight java"><]]>
    </summary>
    
      <category term="security" scheme="http://program.dengshiong.org/tags/security/"/>
    
      <category term="solr" scheme="http://program.dengshiong.org/tags/solr/"/>
    
      <category term="solrj" scheme="http://program.dengshiong.org/tags/solrj/"/>
    
      <category term="搜索引擎" scheme="http://program.dengshiong.org/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Solr权限控制]]></title>
    <link href="http://program.dengshiong.org/2015/01/20/Solr%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://program.dengshiong.org/2015/01/20/Solr权限控制/</id>
    <published>2015-01-20T13:47:37.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>有些情况下，想给Solr增加权限控制，这样就不会被随意更新和删除。关于这点，在<a href="https://wiki.apache.org/solr/SolrSecurity" target="_blank" rel="external">https://wiki.apache.org/solr/SolrSecurity</a>有详细的描述。觉得最坑人的一点是Solr-4470还没resolved。不管它，先使用Jetty添加权限控制</p>
<p>下载已经编译好的solr-4.8.0,进入example目录<br>编辑etc/webdefault.xml,添加如下内容:</p>
<p>[html]</p>
<p><security-constraint><br>    <web-resource-collection><br>      <web-resource-name>Solr authenticated application</web-resource-name><br>      <url-pattern>/update/*</url-pattern><br>    </web-resource-collection><br>    <auth-constraint><br>      <role-name>update-role</role-name><br>    </auth-constraint><br>  </security-constraint></p>
<p>  <login-config><br>    <auth-method>BASIC</auth-method><br>    <realm-name>Solr Update</realm-name><br>  </login-config><br>   [/html]</p>
<p>编辑 etc/jetty.xml, 添加如下内容：</p>
<p>[html]<br> <call name="addBean"><br>      <arg><br>        <new class="org.eclipse.jetty.security.HashLoginService"><br>          <set name="name">Solr Update</set><br>          <set name="config"><systemproperty name="jetty.home" default=".">/etc/realm.properties</systemproperty></set><br>          <set name="refreshInterval">0</set><br>        </new><br>      </arg><br>    </call><br>     [/html]</p>
<p>增加 etc/realm.properties,写入如下内容，也就是用户名，密码以及角色：</p>
<p>[html]index: update, update-role[/html]</p>
<p>启动solr,到exampledocs目录下执行./post.sh solr.xml,返回401错误，说明未认证。修改post.sh,在调用curl时加上用户名和密码，如下：<br>curl –user index:update $URL –data-binary @$f -H ‘Content-type:application/xml’</p>
<p>再次执行./post.sh solr.xml,执行成功，到solr后台查看,可以看到添加文件成功,说明认证设置成功</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有些情况下，想给Solr增加权限控制，这样就不会被随意更新和删除。关于这点，在<a href="https://wiki.apache.org/solr/SolrSecurity" target="_blank" rel="external">https://wiki.ap]]>
    </summary>
    
      <category term="security" scheme="http://program.dengshiong.org/tags/security/"/>
    
      <category term="solr" scheme="http://program.dengshiong.org/tags/solr/"/>
    
      <category term="搜索引擎" scheme="http://program.dengshiong.org/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Lucene中扩展codec功能]]></title>
    <link href="http://program.dengshiong.org/2015/01/16/Lucene%E4%B8%AD%E6%89%A9%E5%B1%95codec%E5%8A%9F%E8%83%BD/"/>
    <id>http://program.dengshiong.org/2015/01/16/Lucene中扩展codec功能/</id>
    <published>2015-01-16T13:04:44.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>从Lucene4.0开始，提供了扩展codec功能，这个功能主要是留给想自己定义索引格式的开发者。<br>在此之前，有必要了解codec主要的作用，codec相关的类主要作用是读写索引。 而通过实现FilterCodec，可以很方便的定义自己的codec。 这个方便主要是可以将许多读写索引部分交给已有的codec实现，而只实现自己需要改进的部分。当然如果这样还不能满足需求 可以重新写一个codec。 </p>
<p>写个简单的例子更容易懂，<br>在Codec.java中，可以看到，读写索引主要实现以下几个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Encodes/decodes postings */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> PostingsFormat <span class="title">postingsFormat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Encodes/decodes docvalues */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DocValuesFormat <span class="title">docValuesFormat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Encodes/decodes stored fields */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> StoredFieldsFormat <span class="title">storedFieldsFormat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Encodes/decodes term vectors */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TermVectorsFormat <span class="title">termVectorsFormat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Encodes/decodes field infos file */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FieldInfosFormat <span class="title">fieldInfosFormat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Encodes/decodes segment info file */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SegmentInfoFormat <span class="title">segmentInfoFormat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Encodes/decodes document normalization values */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> NormsFormat <span class="title">normsFormat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Encodes/decodes live docs */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> LiveDocsFormat <span class="title">liveDocsFormat</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>一个纯文本保存索引的codec是SimpleTextCodec,这个codec的主要目的是用来学习</p>
<p>下面定义自己的codec<br><figure class="highlight"><figcaption><span>class HexinCodec extends FilterCodec &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    final private FieldInfosFormat myTermFieldInfoFormat;&#10;    public HexinCodec() &#123;&#10;        super(&#34;HexinCodec&#34;, new Lucene46Codec());&#10;        myTermFieldInfoFormat = new SimpleTextFieldInfosFormat();&#10;    &#125;&#10;    public FieldInfosFormat fieldInfosFormat() &#123;&#10;        return myTermFieldInfoFormat;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，还是让上面的例子跑起来，首先下载Lucene4.8.0的源码，之后在codecs/src/java下新建包org.apache.lucene.codecs.hexin,<br>在这个包下面新建类HexinCodec.java,复制上面的代码。<br>之后编写测试用的建索引程序Index.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hexin;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Analyzer;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.analysis.standard.StandardAnalyzer;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.codecs.Codec;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.codecs.hexin.HexinCodec;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.codecs.lucene46.Lucene46Codec;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.codecs.simpletext.SimpleTextCodec;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.document.TextField;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig.OpenMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.store.FSDirectory;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.util.Version;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//Codec codec = new SimpleTextCodec();</span></span><br><span class="line">        Codec codec = <span class="keyword">new</span> HexinCodec();</span><br><span class="line">        <span class="comment">//Codec codec = new Lucene46Codec();</span></span><br><span class="line">        String INDEX_DIR = <span class="string">"e:\\index"</span>;</span><br><span class="line">        Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer(Version.LUCENE_48);</span><br><span class="line">        IndexWriterConfig iwc = <span class="keyword">new</span> IndexWriterConfig(Version.LUCENE_48, analyzer);</span><br><span class="line">        iwc.setCodec(codec);</span><br><span class="line">        IndexWriter writer = <span class="keyword">null</span>;</span><br><span class="line">        iwc.setOpenMode(OpenMode.CREATE);</span><br><span class="line">        iwc.setUseCompoundFile(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writer = <span class="keyword">new</span> IndexWriter(FSDirectory.open(<span class="keyword">new</span> File(INDEX_DIR)), iwc);</span><br><span class="line">            Document doc = <span class="keyword">new</span> Document();</span><br><span class="line">            doc.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"who are you, you are a man"</span>, Field.Store.YES));</span><br><span class="line">            doc.add(<span class="keyword">new</span> TextField(<span class="string">"content"</span>, <span class="string">"A long way to go there. Please drive a car"</span>, Field.Store.NO));</span><br><span class="line">            writer.addDocument(doc);</span><br><span class="line">            doc = <span class="keyword">new</span> Document();</span><br><span class="line">            doc.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"are you sure"</span>, Field.Store.YES));</span><br><span class="line">            doc.add(<span class="keyword">new</span> TextField(<span class="string">"content"</span>, <span class="string">"He is a good man. He is a driver"</span>, Field.Store.NO));</span><br><span class="line">            writer.addDocument(doc);</span><br><span class="line">            writer.commit();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编写测试用的搜索例子Search.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hexin;</span><br><span class="line"><span class="keyword">import</span> java.io.File; </span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.codecs.Codec;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.codecs.simpletext.SimpleTextCodec;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.DirectoryReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.Term;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.search.Query;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.search.TermQuery;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.search.ScoreDoc;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.search.TopDocs;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.store.FSDirectory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Search</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Search</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String index = <span class="string">"e:\\index"</span>;</span><br><span class="line">        IndexReader reader = DirectoryReader.open(FSDirectory.open(<span class="keyword">new</span> File(index)));</span><br><span class="line">        IndexSearcher searcher = <span class="keyword">new</span> IndexSearcher(reader);</span><br><span class="line">        String queryString = <span class="string">"driver"</span>;</span><br><span class="line">        Query query = <span class="keyword">new</span> TermQuery(<span class="keyword">new</span> Term(<span class="string">"content"</span>, queryString));</span><br><span class="line">        System.out.println(<span class="string">"Searching for: "</span> + query.toString());</span><br><span class="line">        Date start = <span class="keyword">new</span> Date();</span><br><span class="line">        TopDocs results = searcher.search(query, <span class="keyword">null</span>, <span class="number">100</span>);</span><br><span class="line">        Date end = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"Time: "</span>+(end.getTime()-start.getTime())+<span class="string">"ms"</span>);</span><br><span class="line">        ScoreDoc[] hits = results.scoreDocs;</span><br><span class="line">        <span class="keyword">int</span> numTotalHits = results.totalHits;</span><br><span class="line">        System.out.println(numTotalHits + <span class="string">" total matching documents"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hits.length; i++) &#123;</span><br><span class="line">            String output = <span class="string">""</span>;</span><br><span class="line">            Document doc = searcher.doc(hits[i].doc);</span><br><span class="line">            output += <span class="string">"doc="</span>+hits[i].doc+<span class="string">" score="</span>+hits[i].score;</span><br><span class="line">            String title = doc.get(<span class="string">"title"</span>);</span><br><span class="line">            <span class="keyword">if</span> (title != <span class="keyword">null</span>) &#123;</span><br><span class="line">                output += <span class="string">" "</span> + title;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(output);</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Eclipse中运行Index.java,此时会报错<br>A SPI class of type org.apache.lucene.codecs.Codec with name ‘Lucene46’ does not exist. You need to add the corresponding<br>JAR file supporting this SPI to your classpath.The current classpath supports the following names:[]</p>
<p>问过定坤后，知道一个解决的办法是去官网下载已经编译过的Lucene二进制包,将其中的META-INF拷贝到core/src/java目录下，写上下面两行<br>org.apache.lucene.codecs.simpletext.SimpleTextCodec<br>org.apache.lucene.codecs.hexin.HexinCodec<br>此时即可运行通过。查看索引文件，有一个fld结尾的文件，其内容为文本文件,保存着字段值,这个文件就是通过SimpleTextCodec写入的，<br>而其它文件则是通过Lucene46Codec写入的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从Lucene4.0开始，提供了扩展codec功能，这个功能主要是留给想自己定义索引格式的开发者。<br>在此之前，有必要了解codec主要的作用，codec相关的类主要作用是读写索引。 而通过实现FilterCodec，可以很方便的定义自己的codec。 这个方便主要是可]]>
    </summary>
    
      <category term="Lucene" scheme="http://program.dengshiong.org/tags/Lucene/"/>
    
      <category term="codec" scheme="http://program.dengshiong.org/tags/codec/"/>
    
      <category term="Lucene" scheme="http://program.dengshiong.org/categories/Lucene/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自动脚本登录服务器]]></title>
    <link href="http://program.dengshiong.org/2014/12/27/%E8%87%AA%E5%8A%A8%E8%84%9A%E6%9C%AC%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://program.dengshiong.org/2014/12/27/自动脚本登录服务器/</id>
    <published>2014-12-27T02:59:49.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>我们几乎每天都做这样的操作，输入账号和密码登陆跳转机，从跳转机输入帐号和密码登陆目标机器。当然输入账号和密码登陆跳转机可以在SecureCRT这些客户端中建立登录会话解决，可是后面这一步呢？事实上，后面这一步可以写一个脚本解决。</p>
<p>例如现在需要登录192.168.1.1这台机器,登录用户名和密码都为test，而要登录192.168.1.1，需要先登录到跳板机172.168.1.1,则我们可以新建会话链接192.168.1.1，在其中的会话选项中，ssh2中填上登录172.168.1.1需要的用户名和密码，在登录动作中，我们可以引用一个登录脚本。这里的登录动作指的是登录机器后需要进行的后续操作，在我们这里指的是登录跳板机后需要进行的操作，这当然是登录我们的目标主机了，于是可以写脚本，脚本的内容如下。</p>
<p>#$language = “VBScript”</p>
<p>#$interface = “1.0”<br>Sub main<br>  ‘ turn on synchronous mode so we don’t miss any data<br>  crt.Screen.Synchronous = True<br>  crt.Screen.Send “ssh test@192.168.1.1” &amp; VbCr<br>  ‘ Wait for a tring that looks like “password: “ or “Password: “<br>  crt.Screen.WaitForString “assword:”<br>  ‘ Send your password followed by a carriage return<br>  crt.Screen.Send “test” &amp; VbCr<br>  ‘ turn off synchronous mode to restore normal input processing<br>  crt.Screen.Synchronous = False<br>End Sub<br>如此，我们只需要在SecureCRT中点击一下这个会话，就可以登录到192.168.1.1这台服务器了，是不是很方便？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们几乎每天都做这样的操作，输入账号和密码登陆跳转机，从跳转机输入帐号和密码登陆目标机器。当然输入账号和密码登陆跳转机可以在SecureCRT这些客户端中建立登录会话解决，可是后面这一步呢？事实上，后面这一步可以写一个脚本解决。</p>
<p>例如现在需要登录192.168]]>
    </summary>
    
      <category term="shell" scheme="http://program.dengshiong.org/categories/shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Solr索引升级]]></title>
    <link href="http://program.dengshiong.org/2014/12/27/Solr%E7%B4%A2%E5%BC%95%E5%8D%87%E7%BA%A7/"/>
    <id>http://program.dengshiong.org/2014/12/27/Solr索引升级/</id>
    <published>2014-12-27T02:27:18.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>相信现在很多人还在用Solr1.4,因为Solr1.4许多时候还是满足需求了。可是总有一天会想升级，因为新版本中的一些功能和特性让使用Solr更加方便。而如果要从Solr1.4升级到Solr4.8,可以经过Solr1.4-&gt;Solr3.6-&gt;Solr4.0-&gt;Solr4.8这个步骤.</p>
<p>从Solr1.4-&gt;Solr3.6，去官网下载Solr3.6,使用需要升级的索引搭建起Solr引擎，执行curl ‘<a href="http://localhost:8983/solr/update?optimize=true&amp;maxSegments=1&amp;waitFlush=false&#39;即可" target="_blank" rel="external">http://localhost:8983/solr/update?optimize=true&amp;maxSegments=1&amp;waitFlush=false&#39;即可</a></p>
<p>从Solr3.6-&gt;Solr4.0,去官网下载Solr4.0, 将lucene-core-4.0.jar拷贝到某一目录下，如：lib4.0/lucene-core-4.0.jar(注意，可能需要其它的包如：slf-api和log-back相关包，同样拷贝到lib4.0目录下), 之后执行java -cp “lib4.0/*” org.apache.lucene.index.IndexUpgrader -verbose index/, 这里 index目录存放着Solr3.6索引文件。</p>
<p>从Solr4.0-&gt;Solr4.8, 去官网下载Solr4.8,将lucene-core-4.8拷贝到某一目录下, 如：lib4.0/lucene-core-4.8.jar,之后执行../jdk1.7/bin/java -cp “lib4.8/*” org.apache.lucene.index.IndexUpgrader -delete-prior-commits -verbose index/，这里因为Solr4.8需要用到jdk1.7，所以执行java命令时，必须是jdk1.7。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>相信现在很多人还在用Solr1.4,因为Solr1.4许多时候还是满足需求了。可是总有一天会想升级，因为新版本中的一些功能和特性让使用Solr更加方便。而如果要从Solr1.4升级到Solr4.8,可以经过Solr1.4-&gt;Solr3.6-&gt;Solr4.0-&g]]>
    </summary>
    
      <category term="solr" scheme="http://program.dengshiong.org/tags/solr/"/>
    
      <category term="索引" scheme="http://program.dengshiong.org/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="搜索引擎" scheme="http://program.dengshiong.org/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软连接和硬连接]]></title>
    <link href="http://program.dengshiong.org/2014/12/27/%E8%BD%AF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%A1%AC%E8%BF%9E%E6%8E%A5/"/>
    <id>http://program.dengshiong.org/2014/12/27/软连接和硬连接/</id>
    <published>2014-12-27T02:10:54.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>软连接和硬链接是Linux中经常用到的，详细介绍可以参考<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/</a></p>
<p>要知道软连接和硬链接的区别，必须知道了解Linux的文件系统设计，这其中就有inode这个概念。一个文件被分为用户数据和元数据，其中用户数据是数据存储的地方，而元数据中的inode则是指向这个地方，而文件名只是便于人们记忆而已。对于inode号，可以使用stat或者ls -i查看.</p>
<p>一个inode号可以对应多个文件名，这种情况下就是硬链接。因此创建硬链接并不需要拷贝用户数据，也就是不像cp命令那样,新创建一个inode号，所以创建硬链接速度非常快。只是硬链接有一个局限的地方就是只能对文件创建硬链接，并且不能跨越文件系统。需要注意的一个问题是，修改硬连接，原文件的内容也会修改。而修改原文件，也会修改硬连接。</p>
<p>而创建软连接则会创建新的inode号，只是这个inode号指向的用户数据很特殊，它指向创建软连接的文件。对于软连接，则没有硬链接的那些限制，它可以跨越文件系统，可以对目录创建软链接。只是当把原文件删除后，软连接就变成了死链接了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>软连接和硬链接是Linux中经常用到的，详细介绍可以参考<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/" target="_blank" rel="external">]]>
    </summary>
    
      <category term="硬链接" scheme="http://program.dengshiong.org/tags/%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    
      <category term="软链接" scheme="http://program.dengshiong.org/tags/%E8%BD%AF%E9%93%BE%E6%8E%A5/"/>
    
      <category term="shell" scheme="http://program.dengshiong.org/categories/shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Solr in Action笔记三]]></title>
    <link href="http://program.dengshiong.org/2014/12/14/Solr-in-Action%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
    <id>http://program.dengshiong.org/2014/12/14/Solr-in-Action笔记三/</id>
    <published>2014-12-14T14:12:05.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>Solr关键概念</p>
<p>1.反向索引<br>2.检索词和布尔查询：<br>并查询：<br>+new +house 或者<br>new AND house<br>或查询：<br>new house 或者<br>new OR house<br>排除查询:<br>new house –rental 或者<br>new house NOT rental<br>短语查询：<br>“new home” OR “new house”<br>3 bedrooms” AND “walk in closet” AND “granite countertops”<br>分组查询：<br>New AND (house OR (home NOT improvement NOT depot NOT grown))<br>(+(buying purchasing -renting) +(home house residence –(+property -bedroom)))</p>
<p>对于短语查询，之所以可以实现，是因为在反向索引中保存了词在文档中的位置信息。</p>
<p>3.模糊查询<br>通配符查询：<br>如果需要查询以offic开头的词，只需要查询 offic<em><br>如果要使用通配符在开头的查询，如 </em>ing,则需要将ReversedWildcardFilterFactory添加到字段分析链中</p>
<p>范围查询：<br>yearsOld:[18 TO 21] 18 &lt;= x &lt;= 21<br>yearsOld:{18 TO 21} 18 &lt; x &lt; 21<br>yearsOld:[18 TO 21} 18 &lt;= x &lt; 21<br>created:[2012-02-01T00:00.0Z TO 2012-08-02T00:00.0Z]</p>
<p>编辑距离查询：<br>administrator~ 默认编辑距离为1<br>administrator~1 编辑距离为1<br>administrator~2  编辑距离为2</p>
<p>临近查询：<br>“chief officer”~1 距离为1<br>例如: “chief executive officer”, “officer chief”</p>
<p>4.相关性：<br>Solr默认相关性，距离看文档</p>
<p>5.准确率和召回率<br>准确率说的是一次查询中，查询结果有多少是相关的比率<br>召回率说的是一次查询中，有多少相关结果被返回的比率</p>
<p>一般来说，搜索引擎都是尽量在二者中寻求一个平衡</p>
<p>6.Solr的一些局限<br>Solr无法执行想数据库查询那样复杂的查询<br>当更新一个跨越很多个文档的字段时，Solr将很麻烦<br>对于返回许多文档的查询，Solr的性能将会下降</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Solr关键概念</p>
<p>1.反向索引<br>2.检索词和布尔查询：<br>并查询：<br>+new +house 或者<br>new AND house<br>或查询：<br>new house 或者<br>new OR house<br>排除查询:<br>new ]]>
    </summary>
    
      <category term="solr" scheme="http://program.dengshiong.org/tags/solr/"/>
    
      <category term="搜索引擎" scheme="http://program.dengshiong.org/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[junit找不到方法]]></title>
    <link href="http://program.dengshiong.org/2014/12/13/junit%E6%89%BE%E4%B8%8D%E5%88%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://program.dengshiong.org/2014/12/13/junit找不到方法/</id>
    <published>2014-12-13T03:39:20.000Z</published>
    <updated>2015-12-10T06:07:03.000Z</updated>
    <content type="html"><![CDATA[<p>最近迷上了单元测试，在写单元测试时，提示一下错误：<br>java.lang.NoSuchMethodError: junit.framework.ComparisonFailure.getExpected()Ljava/lang/String;</p>
<p>莫名其妙的，assertFalse怎么可能没有。后来才知道，原来是版本冲突了，因为添加了好多个junit的jar本，而Eclipse只找到最低版本的，将一些低版本的jar去掉就好了。</p>
<p>添加jar这个问题真是蛋疼，在Eclipse里对引用的jar一个目录一个目录的添加，还要肉眼去把低版本的删除，真是麻烦。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近迷上了单元测试，在写单元测试时，提示一下错误：<br>java.lang.NoSuchMethodError: junit.framework.ComparisonFailure.getExpected()Ljava/lang/String;</p>
<p>莫名其妙的，]]>
    </summary>
    
      <category term="junit" scheme="http://program.dengshiong.org/tags/junit/"/>
    
      <category term="Java" scheme="http://program.dengshiong.org/categories/Java/"/>
    
  </entry>
  
</feed>
